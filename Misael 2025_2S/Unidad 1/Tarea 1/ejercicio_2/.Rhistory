# Configurar ventana con 2 gráficos
par(mfrow = c(1, 2), mar = c(5, 5, 4, 2))
# grafico de X y Y
plot(x[1], x[2], xlim = c(0.25, 1.5), ylim = c(0.01,2),
xlab = "x", ylab="y log",
log = "y",
main = "Descenso de Gradiente",
pch = 20, col = "blue", cex = 2)
#-----------------
for (i in 1:max_inter){
#Cada vez que entra suma 1 para tener la cantidad de iteracion
contador <- contador + 1
#-----------------
#calcular alfa k
alpha_k <- (alpha)*(d^floor(i/s))
#calculo del nuevo X
x_nuevo <- x - alpha_k*f_gran(x)
#-----------------
#graficar
points(x_nuevo[1], x_nuevo[2], pch = 20, col = "green", cex = 2)
# Graficar línea de trayectoria entre x y x_nuevo
segments(x[1], x[2], x_nuevo[1], x_nuevo[2], col = "gray70", lwd = 4)
# Calcular distancia recorrida en este paso
distancia_paso <- sqrt((x_nuevo[1] - x[1])^2 + (x_nuevo[2] - x[2])^2)
distancia_total <- distancia_total + distancia_paso
#----------------------------------------------------------------------
#retriccion para evitar errores
if(norm(f_gran(x_nuevo), "2") < tolerancia |
norm(x_nuevo - x, "2") < tolerancia){
break
}
#-----------------
#remplazaomos X original por X nuevo para repetir el ciclo
x <- x_nuevo
}
points(x_nuevo[1], x_nuevo[2], pch = 20, col = "black", cex = 2)
#-----------------------------------------------------------------
plot(contador, alpha_k,
xlim = c(0, max_inter), ylim = c(1 , 0.003),
xlab = "Iteraciones", ylab = "Alpha",
main = "Alpha por paso",
type = "n")
grid()  # Gráfico vacío
for (i in 1:max_inter){
contador_2 <- contador_2 + 1
alpha_k <- (alpha)/(1 + contador_2*gama)
points(contador_2, alpha_k, pch = 20, col = "red", cex = 1)
}
#-----------------------------------------------------------------
cat("El número de iteraciones necesarias es:", contador, "\n")
cat("El valor de alpha inicial:", alpha, "\n")
cat("El valor de alpha final:", alpha_k, "\n")
cat("El punto mínimo encontrado es:", x_nuevo, "\n")
cat("El valor de la función en ese punto es:", f(x_nuevo), "\n")
#funcion objetivo
f <- function (x){
(1 - x[1])^2 + 100*( x[2] - x[1]^2)^2
}
f_gran <- function(x){
dx <- -2*(1 - x[1]) - 400*x[1]*(x[2] - x[1]^2)
dy <- 200*(x[2] - x[1]^2)
return(c(dx,dy))
}
#alfa
alpha <- 0.002
#valor de d
d <- 0.5
#valro de s
s <- 2000
#valor inicial
x <- c(-1,-1)
#-----------------
#constantes
tolerancia <- 1e-6
max_inter <- 10000
#-----------------
#contador
contador <- 0
contador_2 <- 0
distancia_total <- 0
#-----------------
# Configurar ventana con 2 gráficos
par(mfrow = c(1, 2), mar = c(5, 5, 4, 2))
# grafico de X y Y
plot(x[1], x[2], xlim = c(0.25, 1.5), ylim = c(0.01,2),
xlab = "x", ylab="y log",
log = "y",
main = "Descenso de Gradiente",
pch = 20, col = "blue", cex = 2)
#-----------------
for (i in 1:max_inter){
#Cada vez que entra suma 1 para tener la cantidad de iteracion
contador <- contador + 1
#-----------------
#calcular alfa k
alpha_k <- (alpha)*(d^floor(i/s))
#calculo del nuevo X
x_nuevo <- x - alpha_k*f_gran(x)
#-----------------
#graficar
points(x_nuevo[1], x_nuevo[2], pch = 20, col = "green", cex = 2)
# Graficar línea de trayectoria entre x y x_nuevo
segments(x[1], x[2], x_nuevo[1], x_nuevo[2], col = "gray70", lwd = 4)
# Calcular distancia recorrida en este paso
distancia_paso <- sqrt((x_nuevo[1] - x[1])^2 + (x_nuevo[2] - x[2])^2)
distancia_total <- distancia_total + distancia_paso
#----------------------------------------------------------------------
#retriccion para evitar errores
if(norm(f_gran(x_nuevo), "2") < tolerancia |
norm(x_nuevo - x, "2") < tolerancia){
break
}
#-----------------
#remplazaomos X original por X nuevo para repetir el ciclo
x <- x_nuevo
}
points(x_nuevo[1], x_nuevo[2], pch = 20, col = "black", cex = 2)
#-----------------------------------------------------------------
plot(contador, alpha_k,
xlim = c(0, max_inter), ylim = c(0,001 , 0.003),
xlab = "Iteraciones", ylab = "Alpha",
main = "Alpha por paso",
type = "n")
#funcion objetivo
f <- function (x){
(1 - x[1])^2 + 100*( x[2] - x[1]^2)^2
}
f_gran <- function(x){
dx <- -2*(1 - x[1]) - 400*x[1]*(x[2] - x[1]^2)
dy <- 200*(x[2] - x[1]^2)
return(c(dx,dy))
}
#alfa
alpha <- 0.002
#valor de d
d <- 0.5
#valro de s
s <- 2000
#valor inicial
x <- c(-1,-1)
#-----------------
#constantes
tolerancia <- 1e-6
max_inter <- 10000
#-----------------
#contador
contador <- 0
contador_2 <- 0
distancia_total <- 0
#-----------------
# Configurar ventana con 2 gráficos
par(mfrow = c(1, 2), mar = c(5, 5, 4, 2))
# grafico de X y Y
plot(x[1], x[2], xlim = c(0.25, 1.5), ylim = c(0.01,2),
xlab = "x", ylab="y log",
log = "y",
main = "Descenso de Gradiente",
pch = 20, col = "blue", cex = 2)
#-----------------
for (i in 1:max_inter){
#Cada vez que entra suma 1 para tener la cantidad de iteracion
contador <- contador + 1
#-----------------
#calcular alfa k
alpha_k <- (alpha)*(d^floor(i/s))
#calculo del nuevo X
x_nuevo <- x - alpha_k*f_gran(x)
#-----------------
#graficar
points(x_nuevo[1], x_nuevo[2], pch = 20, col = "green", cex = 2)
# Graficar línea de trayectoria entre x y x_nuevo
segments(x[1], x[2], x_nuevo[1], x_nuevo[2], col = "gray70", lwd = 4)
# Calcular distancia recorrida en este paso
distancia_paso <- sqrt((x_nuevo[1] - x[1])^2 + (x_nuevo[2] - x[2])^2)
distancia_total <- distancia_total + distancia_paso
#----------------------------------------------------------------------
#retriccion para evitar errores
if(norm(f_gran(x_nuevo), "2") < tolerancia |
norm(x_nuevo - x, "2") < tolerancia){
break
}
#-----------------
#remplazaomos X original por X nuevo para repetir el ciclo
x <- x_nuevo
}
points(x_nuevo[1], x_nuevo[2], pch = 20, col = "black", cex = 2)
#-----------------------------------------------------------------
plot(contador, alpha_k,
xlim = c(0, max_inter), ylim = c(0,01 , 0.003),
xlab = "Iteraciones", ylab = "Alpha",
main = "Alpha por paso",
type = "n")
#funcion objetivo
f <- function (x){
(1 - x[1])^2 + 100*( x[2] - x[1]^2)^2
}
f_gran <- function(x){
dx <- -2*(1 - x[1]) - 400*x[1]*(x[2] - x[1]^2)
dy <- 200*(x[2] - x[1]^2)
return(c(dx,dy))
}
#alfa
alpha <- 0.002
#valor de d
d <- 0.5
#valro de s
s <- 2000
#valor inicial
x <- c(-1,-1)
#-----------------
#constantes
tolerancia <- 1e-6
max_inter <- 10000
#-----------------
#contador
contador <- 0
contador_2 <- 0
distancia_total <- 0
#-----------------
# Configurar ventana con 2 gráficos
par(mfrow = c(1, 2), mar = c(5, 5, 4, 2))
# grafico de X y Y
plot(x[1], x[2], xlim = c(0.25, 1.5), ylim = c(0.01,2),
xlab = "x", ylab="y log",
log = "y",
main = "Descenso de Gradiente",
pch = 20, col = "blue", cex = 2)
#-----------------
for (i in 1:max_inter){
#Cada vez que entra suma 1 para tener la cantidad de iteracion
contador <- contador + 1
#-----------------
#calcular alfa k
alpha_k <- (alpha)*(d^floor(i/s))
#calculo del nuevo X
x_nuevo <- x - alpha_k*f_gran(x)
#-----------------
#graficar
points(x_nuevo[1], x_nuevo[2], pch = 20, col = "green", cex = 2)
# Graficar línea de trayectoria entre x y x_nuevo
segments(x[1], x[2], x_nuevo[1], x_nuevo[2], col = "gray70", lwd = 4)
# Calcular distancia recorrida en este paso
distancia_paso <- sqrt((x_nuevo[1] - x[1])^2 + (x_nuevo[2] - x[2])^2)
distancia_total <- distancia_total + distancia_paso
#----------------------------------------------------------------------
#retriccion para evitar errores
if(norm(f_gran(x_nuevo), "2") < tolerancia |
norm(x_nuevo - x, "2") < tolerancia){
break
}
#-----------------
#remplazaomos X original por X nuevo para repetir el ciclo
x <- x_nuevo
}
points(x_nuevo[1], x_nuevo[2], pch = 20, col = "black", cex = 2)
#-----------------------------------------------------------------
plot(contador, alpha_k,
xlim = c(0, max_inter), ylim = c(0.001,0.003),
xlab = "Iteraciones", ylab = "Alpha",
main = "Alpha por paso",
type = "n")
grid()  # Gráfico vacío
for (i in 1:max_inter){
contador_2 <- contador_2 + 1
alpha_k <- (alpha)/(1 + contador_2*gama)
points(contador_2, alpha_k, pch = 20, col = "red", cex = 1)
}
#-----------------------------------------------------------------
cat("El número de iteraciones necesarias es:", contador, "\n")
cat("El valor de alpha inicial:", alpha, "\n")
cat("El valor de alpha final:", alpha_k, "\n")
cat("El punto mínimo encontrado es:", x_nuevo, "\n")
cat("El valor de la función en ese punto es:", f(x_nuevo), "\n")
#funcion objetivo
f <- function (x){
(1 - x[1])^2 + 100*( x[2] - x[1]^2)^2
}
f_gran <- function(x){
dx <- -2*(1 - x[1]) - 400*x[1]*(x[2] - x[1]^2)
dy <- 200*(x[2] - x[1]^2)
return(c(dx,dy))
}
#alfa
alpha <- 0.002
#valor de d
d <- 0.5
#valro de s
s <- 2000
#valor inicial
x <- c(-1,-1)
#-----------------
#constantes
tolerancia <- 1e-6
max_inter <- 10000
#-----------------
#contador
contador <- 0
contador_2 <- 0
distancia_total <- 0
#-----------------
# Configurar ventana con 2 gráficos
par(mfrow = c(1, 2), mar = c(5, 5, 4, 2))
# grafico de X y Y
plot(x[1], x[2], xlim = c(0.25, 1.5), ylim = c(0.01,2),
xlab = "x", ylab="y log",
log = "y",
main = "Descenso de Gradiente",
pch = 20, col = "blue", cex = 2)
#-----------------
for (i in 1:max_inter){
#Cada vez que entra suma 1 para tener la cantidad de iteracion
contador <- contador + 1
#-----------------
#calcular alfa k
alpha_k <- (alpha)*(d^floor(i/s))
#calculo del nuevo X
x_nuevo <- x - alpha_k*f_gran(x)
#-----------------
#graficar
points(x_nuevo[1], x_nuevo[2], pch = 20, col = "green", cex = 2)
# Graficar línea de trayectoria entre x y x_nuevo
segments(x[1], x[2], x_nuevo[1], x_nuevo[2], col = "gray70", lwd = 4)
# Calcular distancia recorrida en este paso
distancia_paso <- sqrt((x_nuevo[1] - x[1])^2 + (x_nuevo[2] - x[2])^2)
distancia_total <- distancia_total + distancia_paso
#----------------------------------------------------------------------
#retriccion para evitar errores
if(norm(f_gran(x_nuevo), "2") < tolerancia |
norm(x_nuevo - x, "2") < tolerancia){
break
}
#-----------------
#remplazaomos X original por X nuevo para repetir el ciclo
x <- x_nuevo
}
points(x_nuevo[1], x_nuevo[2], pch = 20, col = "black", cex = 2)
#-----------------------------------------------------------------
plot(contador, alpha_k,
xlim = c(0, max_inter), ylim = c(0.0015,0.0025),
xlab = "Iteraciones", ylab = "Alpha",
main = "Alpha por paso",
type = "n")
grid()  # Gráfico vacío
for (i in 1:max_inter){
contador_2 <- contador_2 + 1
alpha_k <- (alpha)/(1 + contador_2*gama)
points(contador_2, alpha_k, pch = 20, col = "red", cex = 1)
}
#-----------------------------------------------------------------
cat("El número de iteraciones necesarias es:", contador, "\n")
cat("El valor de alpha inicial:", alpha, "\n")
cat("El valor de alpha final:", alpha_k, "\n")
cat("El punto mínimo encontrado es:", x_nuevo, "\n")
cat("El valor de la función en ese punto es:", f(x_nuevo), "\n")
#funcion objetivo
f <- function (x){
(1 - x[1])^2 + 100*( x[2] - x[1]^2)^2
}
f_gran <- function(x){
dx <- -2*(1 - x[1]) - 400*x[1]*(x[2] - x[1]^2)
dy <- 200*(x[2] - x[1]^2)
return(c(dx,dy))
}
#alfa
alpha <- 0.002
alpha_k <- 0
#gama
gama <-alpha/10000
#valor inicial
x <- c(-1,-1)
#constantes
tolerancia <- 1e-6
max_inter <- 10000
#contador
contador <- 0
contador_2 <- 0
distancia_total <- 0
#-----------------
# Configurar ventana con 2 gráficos
par(mfrow = c(1, 2), mar = c(5, 5, 4, 2))
#-----------------------------------------------------------------
# grafico de X y Y
plot(x[1], x[2], xlim = c(0.25, 1.5), ylim = c(0.01,2),
xlab = "x", ylab="y log",
log = "y",
main = "Descenso de Gradiente",
pch = 20, col = "blue", cex = 2)
#-----------------------------------------------------------------
for (i in 1:max_inter){
#Cada vez que entra suma 1 para tener la cantidad de iteracion
contador <- contador + 1
#-----------------
#calcular alfa k
alpha_k <- (alpha)/(1 + contador*gama)
#calculo del nuevo X
x_nuevo <- x - alpha_k*f_gran(x)
#-----------------
#graficar
points(x_nuevo[1], x_nuevo[2], pch = 20, col = "red", cex = 2)
# Graficar línea de trayectoria entre x y x_nuevo
segments(x[1], x[2], x_nuevo[1], x_nuevo[2], col = "gray70", lwd = 4)
#--------------------------------------------------------------------
#retriccion para evitar errores
if(norm(f_gran(x_nuevo), "2") < tolerancia |
norm(x_nuevo - x, "2") < tolerancia){
break
}
#-----------------
#remplazaomos X original por X nuevo para repetir el ciclo
x <- x_nuevo
}
points(x_nuevo[1], x_nuevo[2], pch = 20, col = "black", cex = 2)
#-----------------------------------------------------------------
plot(contador, alpha_k,
xlim = c(0, max_inter), ylim = c(0.00199,0.002),
xlab = "Iteraciones", ylab = "Alpha",
main = "Alpha por tiempo",
type = "n")
grid()  # Gráfico vacío
for (i in 1:max_inter){
contador_2 <- contador_2 + 1
alpha_k <- (alpha)/(1 + contador_2*gama)
points(contador_2, alpha_k, pch = 20, col = "red", cex = 1)
}
#-----------------------------------------------------------------
points(x_nuevo[1], x_nuevo[2], pch = 20, col = "black", cex = 2)
cat("El número de iteraciones necesarias es:", contador, "\n")
cat("El valor de alpha inicial:", alpha, "\n")
cat("El valor de alpha final:", alpha_k, "\n")
cat("El punto mínimo encontrado es:", x_nuevo, "\n")
cat("El valor de la función en ese punto es:", f(x_nuevo), "\n")
#funcion objetivo
f <- function (x){
(1 - x[1])^2 + 100*( x[2] - x[1]^2)^2
}
f_gran <- function(x){
dx <- -2*(1 - x[1]) - 400*x[1]*(x[2] - x[1]^2)
dy <- 200*(x[2] - x[1]^2)
return(c(dx,dy))
}
#alfa
alpha <- 0.002
#valor de d
d <- 0.5
#valro de s
s <- 2000
#valor inicial
x <- c(-1,-1)
#-----------------
#constantes
tolerancia <- 1e-6
max_inter <- 10000
#-----------------
#contador
contador <- 0
contador_2 <- 0
distancia_total <- 0
#-----------------
# Configurar ventana con 2 gráficos
par(mfrow = c(1, 2), mar = c(5, 5, 4, 2))
# grafico de X y Y
plot(x[1], x[2], xlim = c(0.25, 1.5), ylim = c(0.01,2),
xlab = "x", ylab="y log",
log = "y",
main = "Descenso de Gradiente",
pch = 20, col = "blue", cex = 2)
#-----------------
for (i in 1:max_inter){
#Cada vez que entra suma 1 para tener la cantidad de iteracion
contador <- contador + 1
#-----------------
#calcular alfa k
alpha_k <- (alpha)*(d^floor(i/s))
#calculo del nuevo X
x_nuevo <- x - alpha_k*f_gran(x)
#-----------------
#graficar
points(x_nuevo[1], x_nuevo[2], pch = 20, col = "green", cex = 2)
# Graficar línea de trayectoria entre x y x_nuevo
segments(x[1], x[2], x_nuevo[1], x_nuevo[2], col = "gray70", lwd = 4)
# Calcular distancia recorrida en este paso
distancia_paso <- sqrt((x_nuevo[1] - x[1])^2 + (x_nuevo[2] - x[2])^2)
distancia_total <- distancia_total + distancia_paso
#----------------------------------------------------------------------
#retriccion para evitar errores
if(norm(f_gran(x_nuevo), "2") < tolerancia |
norm(x_nuevo - x, "2") < tolerancia){
break
}
#-----------------
#remplazaomos X original por X nuevo para repetir el ciclo
x <- x_nuevo
}
points(x_nuevo[1], x_nuevo[2], pch = 20, col = "black", cex = 2)
#-----------------------------------------------------------------
plot(contador, alpha_k,
xlim = c(0, max_inter), ylim = c(0.0015,0.0025),
xlab = "Iteraciones", ylab = "Alpha",
main = "Alpha por paso",
type = "n")
grid()  # Gráfico vacío
for (i in 1:max_inter){
contador_2 <- contador_2 + 1
alpha_k <- (alpha)/(1 + contador_2*gama)
points(contador_2, alpha_k, pch = 20, col = "red", cex = 1)
}
#-----------------------------------------------------------------
cat("El número de iteraciones necesarias es:", contador, "\n")
cat("El valor de alpha inicial:", alpha, "\n")
cat("El valor de alpha final:", alpha_k, "\n")
cat("El punto mínimo encontrado es:", x_nuevo, "\n")
cat("El valor de la función en ese punto es:", f(x_nuevo), "\n")
