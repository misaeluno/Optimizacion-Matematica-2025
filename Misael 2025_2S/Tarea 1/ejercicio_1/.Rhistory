dx <- 2*(x[1]^2 + x[2] -11)*(2*x[1]) + 2*(x[1] + x[2]^2 -7)
dy <- 2*(x[1]^2 + x[2] -11) + 2*(x[1] + x[2]^2 -7)*(2*x[2])
return(c(dx ,dy))
}
#--------------------------
#aprendisaje
alpha <- 0.01
#alpha <- 0.001
#alpha <- 0.005
x <- c(-2.5 , 2.5)
#-----------------
#constantes
tolerancia <- 1e-6
max_inter <- 10000
#-----------------
#contador
contador <- 0
#-----------------
# Variable para acumular distancia total
distancia_total <- 0
#-----------------
#malla para curva de nivel
x1_seq <- seq(-4, -1, length.out = 500)  # Rango en x1
x2_seq <- seq(1, 6, length.out = 500)  # Rango en x2
#-----------------
# 2. Calcular f(x1, x2) para cada punto de la malla
z <- matrix(NA, nrow = length(x1_seq), ncol = length(x2_seq))
for (i in 1:length(x1_seq)) {
for (j in 1:length(x2_seq)) {
z[i, j] <- f(c(x1_seq[i], x2_seq[j]))
}
}
#-----------------
# Inicializar gráfico
contour(x1_seq, x2_seq, z,
nlevels = 30,           # Número de curvas
col = "black",      # Color de las curvas
lwd = 1,
xlim = c(-3, -2),
ylim = c(2, 4),
xlab = "x1",
ylab = "x2",
main = "Descenso de Gradiente sobre Himmelblau")
#-----------------
# Agregar leyenda
legend("topright", legend = c("Inicio", "Trayectoria", "Final", "inicial"),
col = c("blue", "red", "black","orange"), pch = 20, cex = 1)
#-----------------
points(-2.5, 2.5, pch = 20, col = "orange", cex = 2)
for (i in 1:max_inter){
#Cada vez que entra suma 1 para tener la cantidad de iteracion
contador <- contador + 1
#-----------------
#calculo del nuevo X
x_nuevo <- x - alpha*f_prima(x)
#-----------------
#graficar
points(x_nuevo[1], x_nuevo[2], pch = 20, col = "red", cex = 2)
#-------------------------------------------------------------------
# Graficar línea de trayectoria entre x y x_nuevo
segments(x[1], x[2], x_nuevo[1], x_nuevo[2], col = "gray70", lwd = 4)
#-----------------
# Calcular distancia recorrida en este paso
distancia_paso <- sqrt((x_nuevo[1] - x[1])^2 + (x_nuevo[2] - x[2])^2)
distancia_total <- distancia_total + distancia_paso
#-------------------------------------------------------------------
#retriccion para evitar errores
if(norm(f_prima(x_nuevo), "2") < tolerancia |
norm(x_nuevo - x, "2") < tolerancia){
break
}
#-----------------
#remplazaomos X original por X nuevo para repetir el ciclo
x <- x_nuevo
}
# Mostrar resultados
points(x_nuevo[1], x_nuevo[2], pch = 20, col = "black", cex = 2)
cat("El número de iteraciones necesarias es:", contador, "\n")
cat("El valor de alpha es:", alpha, "\n")
cat("El punto mínimo encontrado es:", x_nuevo, "\n")
cat("El valor de la función en ese punto es:", f(x_nuevo), "\n")
#funcion objetivo
f <- function (x){
(1 - x[1])^2 + 100*( x[2] - x[1]^2)^2
}
f_gran <- function(x){
dx <- -2*(1 - x[1]) - 400*x[1]*(x[2] - x[1]^2)
dy <- 200*(x[2] - x[1]^2)
return(c(dx,dy))
}
#alfa
alpha <- 0.002
#valor de d
d <- 0.5
#valro de s
s <- 2000
#valor inicial
x <- c(-1,-1)
#-----------------
#constantes
tolerancia <- 1e-6
max_inter <- 10000
#-----------------
#contador
contador <- 0
contador_2 <- 0
distancia_total <- 0
#-----------------
# Configurar ventana con 2 gráficos
par(mfrow = c(1, 2), mar = c(5, 5, 4, 2))
# grafico de X y Y
plot(x[1], x[2], xlim = c(0.25, 1.5), ylim = c(0.01,2),
xlab = "x", ylab="y log",
log = "y",
main = "Descenso de Gradiente",
pch = 20, col = "blue", cex = 2)
#-----------------
for (i in 1:max_inter){
#Cada vez que entra suma 1 para tener la cantidad de iteracion
contador <- contador + 1
#-----------------
#calcular alfa k
alpha_k <- (alpha)*(d^floor(i/s))
#calculo del nuevo X
x_nuevo <- x - alpha_k*f_gran(x)
#-----------------
#graficar
points(x_nuevo[1], x_nuevo[2], pch = 20, col = "green", cex = 2)
# Graficar línea de trayectoria entre x y x_nuevo
segments(x[1], x[2], x_nuevo[1], x_nuevo[2], col = "gray70", lwd = 4)
# Calcular distancia recorrida en este paso
distancia_paso <- sqrt((x_nuevo[1] - x[1])^2 + (x_nuevo[2] - x[2])^2)
distancia_total <- distancia_total + distancia_paso
#----------------------------------------------------------------------
#retriccion para evitar errores
if(norm(f_gran(x_nuevo), "2") < tolerancia |
norm(x_nuevo - x, "2") < tolerancia){
break
}
#-----------------
#remplazaomos X original por X nuevo para repetir el ciclo
x <- x_nuevo
}
points(x_nuevo[1], x_nuevo[2], pch = 20, col = "black", cex = 2)
#-----------------------------------------------------------------
plot(contador, alpha_k,
xlim = c(0, max_inter), ylim = c(0,0.002),
xlab = "Iteraciones", ylab = "Alpha",
main = "Decaimiento de Alpha",
type = "n")
grid()  # Gráfico vacío
for (i in 1:max_inter){
contador_2 <- contador_2 + 1
alpha_k <- (alpha)/(1 + contador_2*gama)
points(contador_2, alpha_k, pch = 20, col = "red", cex = 1)
}
#-----------------------------------------------------------------
cat("El número de iteraciones necesarias es:", contador, "\n")
cat("El valor de alpha inicial:", alpha, "\n")
cat("El valor de alpha final:", alpha_k, "\n")
cat("El punto mínimo encontrado es:", x_nuevo, "\n")
cat("El valor de la función en ese punto es:", f(x_nuevo), "\n")
#funcion objetico
f <- function(x) {
(x[1]^2 + x[2] -11)^2 + (x[1] + x[2]^2 -7)^2
}
#--------------------------
#gradeinte
f_prima <- function(x){
dx <- 2*(x[1]^2 + x[2] -11)*(2*x[1]) + 2*(x[1] + x[2]^2 -7)
dy <- 2*(x[1]^2 + x[2] -11) + 2*(x[1] + x[2]^2 -7)*(2*x[2])
return(c(dx ,dy))
}
#--------------------------
#aprendisaje
gama <- 0.5
#gama <- 0.7
#gama <- 0.9
alpha <- 0.005
v <- c(0,0)
x <- c(-2.5,2.5)
#-----------------
#constantes
tolerancia <- 1e-6
max_inter <- 10000
#-----------------
#contador
contador <- 0
#-----------------
# Variable para acumular distancia total
distancia_total <- 0
#-----------------
# Inicializar gráfico
plot(x[1], x[2], xlim = c(-3, -2), ylim = c(0, 4),
xlab = "x", ylab = "y", main = "Descenso de Gradiente - Función Himmelblau",
pch = 20, col = "blue", cex = 2)
#-----------------
# Agregar leyenda
legend("topright", legend = c("Inicio", "Trayectoria", "Final"),
col = c("blue", "red", "black"), pch = 20, cex = 1)
#-----------------
for (i in 1:max_inter){
#Cada vez que entra suma 1 para tener la cantidad de iteracion
contador <- contador + 1
#-----------------
#calculo de la velocidad
v <- (gama * v) + f_prima(x)
#-----------------
#calculo del nuevo X
x_nuevo <- x - alpha*v
#-----------------
#graficar
points(x_nuevo[1], x_nuevo[2], pch = 20, col = "red", cex = 2)
#-------------------------------------------------------------------
# Graficar línea de trayectoria entre x y x_nuevo
segments(x[1], x[2], x_nuevo[1], x_nuevo[2], col = "gray70", lwd = 4)
#-----------------
# Calcular distancia recorrida en este paso
distancia_paso <- sqrt((x_nuevo[1] - x[1])^2 + (x_nuevo[2] - x[2])^2)
distancia_total <- distancia_total + distancia_paso
#-------------------------------------------------------------------
#retriccion para evitar erroress
if(norm(f_prima(x_nuevo), "2") < tolerancia |
norm(x_nuevo - x, "2") < tolerancia){
break
}
#-----------------
#remplazaomos X original por X nuevo para repetir el ciclo
x <- x_nuevo
}
points(x_nuevo[1], x_nuevo[2], pch = 20, col = "black", cex = 2)
cat("El número de iteraciones necesarias es:", contador, "\n")
cat("El valor de alpha es:", alpha, "\n")
cat("el valor de Gama es: ",gama, "\n")
cat("El punto mínimo encontrado es:", x_nuevo, "\n")
cat("El valor de la función en ese punto es:", f(x_nuevo), "\n")
#funcion objetico
f <- function(x) {
(x[1]^2 + x[2] -11)^2 + (x[1] + x[2]^2 -7)^2
}
#--------------------------
#gradeinte
f_prima <- function(x){
dx <- 2*(x[1]^2 + x[2] -11)*(2*x[1]) + 2*(x[1] + x[2]^2 -7)
dy <- 2*(x[1]^2 + x[2] -11) + 2*(x[1] + x[2]^2 -7)*(2*x[2])
return(c(dx ,dy))
}
#--------------------------
#aprendisaje
gama <- 0.5
#gama <- 0.7
#gama <- 0.9
alpha <- 0.005
v <- c(0,0)
x <- c(-2.5,2.5)
#-----------------
#constantes
tolerancia <- 1e-6
max_inter <- 10000
#-----------------
#contador
contador <- 0
#-----------------
# Variable para acumular distancia total
distancia_total <- 0
#-----------------
#malla para curva de nivel
x1_seq <- seq(-4, -1, length.out = 500)  # Rango en x1
x2_seq <- seq(1, 6, length.out = 500)  # Rango en x2
#-----------------
# 2. Calcular f(x1, x2) para cada punto de la malla
z <- matrix(NA, nrow = length(x1_seq), ncol = length(x2_seq))
for (i in 1:length(x1_seq)) {
for (j in 1:length(x2_seq)) {
z[i, j] <- f(c(x1_seq[i], x2_seq[j]))
}
}
#-----------------
# Inicializar gráfico
contour(x1_seq, x2_seq, z,
nlevels = 30,           # Número de curvas
col = "black",      # Color de las curvas
lwd = 1,
xlim = c(-3, -2),
ylim = c(2, 4),
xlab = "x1",
ylab = "x2",
main = "Descenso de Gradiente sobre Himmelblau")
#-----------------
# Agregar leyenda
legend("topright", legend = c("Inicio", "Trayectoria", "Final", "inicial"),
col = c("blue", "red", "black","orange"), pch = 20, cex = 1)
#-----------------
#Punto inicial
points(-2.5, 2.5, pch = 20, col = "orange", cex = 2)
#-----------------
for (i in 1:max_inter){
#Cada vez que entra suma 1 para tener la cantidad de iteracion
contador <- contador + 1
#-----------------
#calculo de la velocidad
v <- (gama * v) + f_prima(x)
#-----------------
#calculo del nuevo X
x_nuevo <- x - alpha*v
#-----------------
#graficar
points(x_nuevo[1], x_nuevo[2], pch = 20, col = "red", cex = 2)
#-------------------------------------------------------------------
# Graficar línea de trayectoria entre x y x_nuevo
segments(x[1], x[2], x_nuevo[1], x_nuevo[2], col = "gray70", lwd = 4)
#-----------------
# Calcular distancia recorrida en este paso
distancia_paso <- sqrt((x_nuevo[1] - x[1])^2 + (x_nuevo[2] - x[2])^2)
distancia_total <- distancia_total + distancia_paso
#-------------------------------------------------------------------
#retriccion para evitar erroress
if(norm(f_prima(x_nuevo), "2") < tolerancia |
norm(x_nuevo - x, "2") < tolerancia){
break
}
#-----------------
#remplazaomos X original por X nuevo para repetir el ciclo
x <- x_nuevo
}
points(x_nuevo[1], x_nuevo[2], pch = 20, col = "black", cex = 2)
cat("El número de iteraciones necesarias es:", contador, "\n")
cat("El valor de alpha es:", alpha, "\n")
cat("el valor de Gama es: ",gama, "\n")
cat("El punto mínimo encontrado es:", x_nuevo, "\n")
cat("El valor de la función en ese punto es:", f(x_nuevo), "\n")
#funcion objetico
f <- function(x) {
(x[1]^2 + x[2] -11)^2 + (x[1] + x[2]^2 -7)^2
}
#--------------------------
#gradeinte
f_prima <- function(x){
dx <- 2*(x[1]^2 + x[2] -11)*(2*x[1]) + 2*(x[1] + x[2]^2 -7)
dy <- 2*(x[1]^2 + x[2] -11) + 2*(x[1] + x[2]^2 -7)*(2*x[2])
return(c(dx ,dy))
}
#--------------------------
#aprendisaje
gama <- 0.5
#gama <- 0.7
#gama <- 0.9
alpha <- 0.005
v <- c(0,0)
x <- c(-2.5,2.5)
#-----------------
#constantes
tolerancia <- 1e-6
max_inter <- 10000
#-----------------
#contador
contador <- 0
#-----------------
# Variable para acumular distancia total
distancia_total <- 0
#-----------------
#malla para curva de nivel
x1_seq <- seq(-4, -1, length.out = 500)  # Rango en x1
x2_seq <- seq(1, 6, length.out = 500)  # Rango en x2
#-----------------
# 2. Calcular f(x1, x2) para cada punto de la malla
z <- matrix(NA, nrow = length(x1_seq), ncol = length(x2_seq))
for (i in 1:length(x1_seq)) {
for (j in 1:length(x2_seq)) {
z[i, j] <- f(c(x1_seq[i], x2_seq[j]))
}
}
#-----------------
# Inicializar gráfico
contour(x1_seq, x2_seq, z,
nlevels = 30,           # Número de curvas
col = "black",      # Color de las curvas
lwd = 1,
xlim = c(-3, -2),
ylim = c(2, 4),
xlab = "x1",
ylab = "x2",
main = "Descenso de Gradiente sobre Himmelblau")
#-----------------
#Punto inicial
points(-2.5, 2.5, pch = 20, col = "orange", cex = 2)
#-----------------
for (i in 1:max_inter){
#Cada vez que entra suma 1 para tener la cantidad de iteracion
contador <- contador + 1
#-----------------
#calculo de la velocidad
v <- (gama * v) + f_prima(x)
#-----------------
#calculo del nuevo X
x_nuevo <- x - alpha*v
#-----------------
#graficar
points(x_nuevo[1], x_nuevo[2], pch = 20, col = "red", cex = 2)
#-------------------------------------------------------------------
# Graficar línea de trayectoria entre x y x_nuevo
segments(x[1], x[2], x_nuevo[1], x_nuevo[2], col = "gray70", lwd = 4)
#-----------------
# Calcular distancia recorrida en este paso
distancia_paso <- sqrt((x_nuevo[1] - x[1])^2 + (x_nuevo[2] - x[2])^2)
distancia_total <- distancia_total + distancia_paso
#-------------------------------------------------------------------
#retriccion para evitar erroress
if(norm(f_prima(x_nuevo), "2") < tolerancia |
norm(x_nuevo - x, "2") < tolerancia){
break
}
#-----------------
#remplazaomos X original por X nuevo para repetir el ciclo
x <- x_nuevo
}
points(x_nuevo[1], x_nuevo[2], pch = 20, col = "black", cex = 2)
cat("El número de iteraciones necesarias es:", contador, "\n")
cat("El valor de alpha es:", alpha, "\n")
cat("el valor de Gama es: ",gama, "\n")
cat("El punto mínimo encontrado es:", x_nuevo, "\n")
cat("El valor de la función en ese punto es:", f(x_nuevo), "\n")
#funcion objetico
f <- function(x) {
(x[1]^2 + x[2] -11)^2 + (x[1] + x[2]^2 -7)^2
}
#--------------------------
#gradeinte
f_prima <- function(x){
dx <- 2*(x[1]^2 + x[2] -11)*(2*x[1]) + 2*(x[1] + x[2]^2 -7)
dy <- 2*(x[1]^2 + x[2] -11) + 2*(x[1] + x[2]^2 -7)*(2*x[2])
return(c(dx ,dy))
}
#--------------------------
#aprendisaje
alpha <- 0.01
#alpha <- 0.001
#alpha <- 0.005
x <- c(-2.5 , 2.5)
#-----------------
#constantes
tolerancia <- 1e-6
max_inter <- 10000
#-----------------
#contador
contador <- 0
#-----------------
# Variable para acumular distancia total
distancia_total <- 0
#-----------------
#malla para curva de nivel
x1_seq <- seq(-4, -1, length.out = 500)  # Rango en x1
x2_seq <- seq(1, 6, length.out = 500)  # Rango en x2
#-----------------
# 2. Calcular f(x1, x2) para cada punto de la malla
z <- matrix(NA, nrow = length(x1_seq), ncol = length(x2_seq))
for (i in 1:length(x1_seq)) {
for (j in 1:length(x2_seq)) {
z[i, j] <- f(c(x1_seq[i], x2_seq[j]))
}
}
#-----------------
# Inicializar gráfico
contour(x1_seq, x2_seq, z,
nlevels = 30,           # Número de curvas
col = "black",      # Color de las curvas
lwd = 1,
xlim = c(-3, -2),
ylim = c(2, 4),
xlab = "x1",
ylab = "x2",
main = "Descenso de Gradiente sobre Himmelblau")
#-----------------
# Agregar leyenda
legend("topright", legend = c("Inicio", "Trayectoria", "Final", "inicial"),
col = c("blue", "red", "black","orange"), pch = 20, cex = 1)
#-----------------
#Punto inicial
points(-2.5, 2.5, pch = 20, col = "orange", cex = 2)
#-----------------
for (i in 1:max_inter){
#Cada vez que entra suma 1 para tener la cantidad de iteracion
contador <- contador + 1
#-----------------
#calculo del nuevo X
x_nuevo <- x - alpha*f_prima(x)
#-----------------
#graficar
points(x_nuevo[1], x_nuevo[2], pch = 20, col = "red", cex = 2)
#-------------------------------------------------------------------
# Graficar línea de trayectoria entre x y x_nuevo
segments(x[1], x[2], x_nuevo[1], x_nuevo[2], col = "gray70", lwd = 4)
#-----------------
# Calcular distancia recorrida en este paso
distancia_paso <- sqrt((x_nuevo[1] - x[1])^2 + (x_nuevo[2] - x[2])^2)
distancia_total <- distancia_total + distancia_paso
#-------------------------------------------------------------------
#retriccion para evitar errores
if(norm(f_prima(x_nuevo), "2") < tolerancia |
norm(x_nuevo - x, "2") < tolerancia){
break
}
#-----------------
#remplazaomos X original por X nuevo para repetir el ciclo
x <- x_nuevo
}
# Mostrar resultados
points(x_nuevo[1], x_nuevo[2], pch = 20, col = "black", cex = 2)
cat("El número de iteraciones necesarias es:", contador, "\n")
cat("El valor de alpha es:", alpha, "\n")
cat("El punto mínimo encontrado es:", x_nuevo, "\n")
cat("El valor de la función en ese punto es:", f(x_nuevo), "\n")
